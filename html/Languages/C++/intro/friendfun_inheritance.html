<html>
    <head>
        <title>Friendship and inheritance </title>
    </head>
    <body>
        <h3 id="friend">Friend functions </h3>
        <div class="cont">
            <p>In principle, private and protected members of a class cannot be accessed from outside the same class in which
                they are declared. However, this rule does not affect friends.<br>
                Friends are functions or classes declared as such.<br>
                If we want to declare an external function as friend of a class, thus allowing this function to have access to the
                private and protected members of this class, we do it by declaring a prototype of this external function within the
                class, and preceding it with the keyword friend: 
            </p>
        </div>
        <div class="code">
<pre><i>// friend functions</i>
#include &lt;iostream&gt;
using namespace std;
class CRectangle {
    int width, height;
    public:
    void set_values (int, int);
    int area () {return (width * height);}
    friend CRectangle duplicate (CRectangle);
};
void CRectangle::set_values (int a, int b) {
    width = a;
    height = b;
}
CRectangle duplicate (CRectangle rectparam)
{
    CRectangle rectres;
    rectres.width = rectparam.width*2;
    rectres.height = rectparam.height*2;
    return (rectres);
}
int main () {
    CRectangle rect, rectb;
    rect.set_values (2,3);
    rectb = duplicate (rect);
    cout << rectb.area();
    return 0;
}</pre>
        </div>
        <div class="cont">
            <p>output:
            </p>
        </div>
        <div class="code">
            <pre>24</pre>
        </div>
        <h3 id="friendcl">Friend classes </h3>
        <div class="cont">
            <p>Just as we have the possibility to define a friend function, we can also define a class as friend of another one,
                granting that first class access to the protected and private members of the second one.
            </p>
        </div>
        <div class="code">
<pre><i>// friend class</i>
#include &lt;iostream&gt;
using namespace std;
class CSquare;
class CRectangle {
    int width, height;
    public:
    int area ()
    {return (width * height);}
    void convert (CSquare a);
};
class CSquare {
    private:
    int side;
    public:
    void set_side (int a)
    {side=a;}
    friend class CRectangle;
};
void CRectangle::convert (CSquare a) {
      = a.side;
    height = a.side;
}   
int main () {
    CSquare sqr;
    CRectangle rect;
    sqr.set_side(4);
    rect.convert(sqr);
    cout << rect.area();
    return 0;
}</pre>
        </div>
        <div class="cont">
            <p>output:
            </p>
        </div>
        <div class="code">
            <pre>16</pre>
        </div>
        <div class="cont">
            <p>In this example, we have declared <em>CRectangle</em> as a friend of <em>CSquare</em> so that <em>CRectangle</em> member functions could
                have access to the protected and private members of <em>CSquare</em>, more concretely to <em>CSquare::side</em>, which describes
                the side width of the square. 
            </p>
        </div>
        <h3 id="inhebwclass">Inheritance between classes </h3>
        <div class="cont">
            <p>o derive a class from another, we use a colon (:) in the declaration of the derived class using the
                following format:
            </p>
        </div>
        <div class="code">
<pre>class derived_class_name: public base_class_name
{ /*...*/ };</pre>
        </div>
        <div class="cont">
            <p>Where <em>derived_class_name</em> is the name of the derived class and <em>base_class_name</em> is the name of the class on
                which it is based. The public access specifier may be replaced by any one of the other access specifiers protected
                and private. This access specifier describes the minimum access level for the members that are inherited from the
                base class.
            </p>
        </div>
        <div class="code">
<pre><i>// derived classes</i>
#include &lt;iostream&gt;
using namespace std;
class CPolygon {
    protected:
    int width, height;
    public:
    void set_values (int a, int b)
        { width=a; height=b;}
    };
class CRectangle: public CPolygon {
    public:
    int area ()
        { return (width * height); }
    };
class CTriangle: public CPolygon {
    public:
    int area ()
        { return (width * height / 2); }
    };
int main () {
    CRectangle rect;
    CTriangle trgl;
    rect.set_values (4,5);
    trgl.set_values (4,5);
    cout << rect.area() << endl;
    cout << trgl.area() << endl;
    return 0;
} 
</pre>
        </div>
        <h3 id="base">What is inherited from the base class? </h3>
        <div class="cont">
            <p>In principle, a derived class inherits every member of a base class except:
            </p>
        </div>
        <div class="unl">
            <ul>
                <li>its constructor and its destructor</li>
                <li>its operator=() members</li>
                <lI>its friends</lI>
            </ul>
        </div>
        <div class="cont">
            <p>Although the constructors and destructors of the base class are not inherited themselves, its default constructor
                (i.e., its constructor with no parameters) and its destructor are always called when a new object of a derived class
                is created or destroyed.<br>
                If the base class has no default constructor or you want that an overloaded constructor is called when a new
                derived object is created, you can specify it in each constructor definition of the derived class:      
            </p>
        </div>
        <div class="code">
            <pre>derived_constructor_name (parameters) : base_constructor_name (parameters) {...}</pre>
        </div>
        <div class="cont">
            <p>For example:
            </p>
        </div>
        <div class="code">
<pre><i>// constructors and derived classes</i>
#include &lt;iostream&gt;
using namespace std;
class mother {
    public:
    mother ()
        { cout << "mother: no parameters\n"; }
    mother (int a)
        { cout << "mother: int parameter\n"; }
};
class daughter : public mother {
    public:
    daughter (int a)
        { cout << "daughter: int parameter\n\n"; }
};
class son : public mother {
    public:
    son (int a) : mother (a)
        { cout << "son: int parameter\n\n"; }
};
int main () {
    daughter cynthia (0);
    son daniel(0);
    
    return 0;
} 
</pre>
        </div>
        <div class="cont">
            <p>output:
            </p>
        </div>
        <div class="code">
<pre>mother: no parameters
daughter: int parameter
    
mother: int parameter
son: int parameter </pre>
        </div>
        <h3 id="multiple">Multiple inheritance </h3>
        <div class="cont">
            <p>In C++ it is perfectly possible that a class inherits members from more than one class. This is done by simply
                separating the different base classes with commas in the derived class declaration.<br>example:
            </p>
        </div>
        <div class="code">
<pre><i>// multiple inheritance</i>
#include &lt;iostream&gt;
using namespace std;
class CPolygon {
    protected:
    int width, height;
    public:
    void set_values (int a, int b)
        { width=a; height=b;}
    };
class COutput {
    public:
    void output (int i);
};
    void COutput::output (int i) {
        cout << i << endl;
    }
class CRectangle: public CPolygon, public COutput {
    public:
    int area ()
        { return (width * height); }
};
class CTriangle: public CPolygon, public COutput {
    public:
    int area ()
        { return (width * height / 2); }
};
    
int main () {
    CRectangle rect;
    CTriangle trgl;
    rect.set_values (4,5);
    trgl.set_values (4,5);
    rect.output (rect.area());
    trgl.output (trgl.area());
    return 0;
}</pre>
        </div>
        <div class="cont">
            <p>output:
            </p>
        </div>
        <div class="code">
<pre>20
10
</pre>
        </div>
    </body>
</html>