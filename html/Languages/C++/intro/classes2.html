<html>
    <head>
        <title>classes2</title>
    </head>
    <body>
       <h3 id="class">Overloading operators </h3> 
       <div class="cont">
        <p>C++ incorporates the option to use standard operators to perform operations with classes in addition to with
            fundamental types. For example:             
        </p>
    </div>
    <div class="code">
<pre>int a, b, c;
a = b + c;</pre>
    </div>
    <div class="cont">
        <p>This is obviously valid code in C++, since the different variables of the addition are all fundamental types.
            Nevertheless, it is not so obvious that we could perform an operation similar to the following one:
        </p>
    </div>
    <div class="code">
<pre>struct {
    string product;
    float price;
} a, b, c;
a = b + c;</pre>
    </div>
    <div class="cont">
        <p>In fact, this will cause a compilation error, since we have not defined the behavior our class should have with
            addition operations. <br> Here is a list of all the operators that can be overloaded:
        </p>
    </div>
    <div class="tbl">
        <table>
            <tr>
                <td>+</td> <td>-</td> <td>*</td> <td>/</td> <td><</td> <td>></td> <td>~</td> <td>&=</td>
            </tr>
            <tr>
                <td>+=</td> <td>-=</td> <td>*=</td> <td>/=</td> <td><<</td> <td>>></td> <td>^=</td> <td>|=</td>
            </tr>
            <tr>
                <td>++</td> <td>--</td> <td><=</td> <td>>=</td> <td><<=</td> <td>>>=</td> <td>&&</td> <td>||</td>
            </tr>
            <tr>
                <td>new</td> <td>delete</td> <td>new[]</td> <td>delete[]</td> <td>[]</td> <td>()</td> <td>%=</td> <td>,</td>
            </tr>
        </table>
    </div>
    <div class="cont">
        <p>To overload an operator in order to use it with classes we declare operator functions, which are regular functions
            whose names are the <i>operator</i> keyword followed by the operator sign that we want to overload. The format is:
        </p>
    </div>
    <div class="code">
        <pre>type operator sign (parameters) { /*...*/ }</pre>
    </div>
    <div class="cont">
        <p>Here you have an example that overloads the addition operator (+).
        </p>
    </div>
    <div class="code">
<pre><i>// vectors: overloading operators example</i>
#include &lt;iostream&gt;
using namespace std;
class CVector {
    public:
    int x,y;
    CVector () {};
    CVector (int,int);
    CVector operator + (CVector);
};
CVector::CVector (int a, int b) {
    x = a;
    y = b;
}
CVector CVector::operator+ (CVector param) {
    CVector temp;
    temp.x = x + param.x;
    temp.y = y + param.y;
    return (temp);
}
int main () {
    CVector a (3,1);
    CVector b (1,2);
    CVector c;
    c = a + b;
    cout << c.x << "," << c.y;
    return 0;
} </pre>
    </div>
    <div class="cont">
        <p>output:
        </p>
    </div>
    <div class="code">
        <pre>4,3</pre>
    </div>
    <div class="cont">
        <p>It may be a little confusing to see so many times the <i>CVector</i> identifier. But, consider that some of them refer to
            the class name (type) <i>CVector</i> and some others are functions with that name (constructors must have the same
            name as the class). Do not confuse them:
        </p>
    </div>
    <div class="code">
<pre>CVector (int, int);          <i>// function name CVector (constructor)</i>
CVector operator+ (CVector); <i>// function returns a CVector</i></pre>
    </div>
    <h3 id="this">The keyword this </h3>
    <div class="cont">
        <p>The keyword <em>this</em> represents a pointer to the object whose member function is being executed. It is a pointer to
            the object itself. <br>One of its uses can be to check if a parameter passed to a member function is the object itself. For example, 
        </p>
    </div>
    <div class="code">
<pre><i>// this</i>
#include &lt;iostream&gt;
using namespace std;
class CDummy {
    public:
    int isitme (CDummy& param);
};
int CDummy::isitme (CDummy& param)
{
    if (&param == this) return true;
    else return false;
}
int main () {
    CDummy a;
    CDummy* b = &a;
    if ( b->isitme(a) )
    cout << "yes, &a is b";
    return 0;
}</pre>
    </div>
    <div class="cont">
        <p>output:
        </p>
    </div>
    <div class="code">
        <pre>yes, &a is b</pre>
    </div>
    <h3 id="static">Static members</h3>
    <div class="cont">
        <p>A class can contain <em>static</em> members, either data or functions.<br>
            Static data members of a class are also known as "class variables", because there is only one unique value for all
            the objects of that same class. Their content is not different from one object of this class to another.<br>
            For example, it may be used for a variable within a class that can contain a counter with the number of objects of
            that class that are currently allocated, as in the following example: 
        </p>
    </div>
    <div class="code">
<pre><i>// static members in classes</i>
#include &lt;iostream&gt;
using namespace std;
class CDummy {
    public:
    static int n;
    CDummy () { n++; };
    ~CDummy () { n--; };
};
int CDummy::n=0;
int main () {
    CDummy a;
    CDummy b[5];
    CDummy * c = new CDummy;
    cout << a.n << endl;
    delete c;
    cout << CDummy::n << endl;
    return 0;
} </pre>
    </div>
    <div class="cont">
        <p>output:
        </p>
    </div>
    <div class="code">
<pre>7
6</pre>
    </div>

    
        
    
    </body>
</html>